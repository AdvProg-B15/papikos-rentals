package id.ac.ui.cs.advprog.papikos.rentals;

import id.ac.ui.cs.advprog.papikos.rentals.enums.RentalStatus;
import id.ac.ui.cs.advprog.papikos.rentals.model.Rental;
import id.ac.ui.cs.advprog.papikos.rentals.repository.RentalRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.test.context.ActiveProfiles;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

@ActiveProfiles("test")
@DataJpaTest
class RentalRepositoryIntegrationTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private RentalRepository rentalRepository;

    private UUID tenantId1, tenantId2;
    private UUID kosId1, kosId2;
    private UUID ownerId1;

    @BeforeEach
    void setUp() {
        tenantId1 = UUID.randomUUID();
        tenantId2 = UUID.randomUUID();
        kosId1 = UUID.randomUUID();
        kosId2 = UUID.randomUUID();
        ownerId1 = UUID.randomUUID();
    }

    @Test
    @DisplayName("When save Rental, then PrePersist callbacks should set createdAt, updatedAt, and rentalEndDate")
    void testPrePersistCallbacksAndSave() {
        Rental rental = new Rental();
        rental.setTenantUserId(tenantId1);
        rental.setKosId(kosId1);
        rental.setOwnerUserId(ownerId1);
        rental.setSubmittedTenantName("Test Persist");
        rental.setSubmittedTenantPhone("123");
        rental.setRentalStartDate(LocalDate.now().plusDays(1));
        rental.setRentalDurationMonths(1);
        rental.setStatus(RentalStatus.PENDING_APPROVAL);

        Rental savedRental = rentalRepository.save(rental);
        // entityManager.flush(); // Ensure changes are written to in-memory DB if needed before further asserts

        assertThat(savedRental.getId()).isNotNull(); // UUID should be generated by @PrePersist
        assertThat(savedRental.getCreatedAt()).isNotNull();
        assertThat(savedRental.getUpdatedAt()).isNotNull();
        assertThat(savedRental.getCreatedAt()).isEqualTo(savedRental.getUpdatedAt()); // Initially same
        assertThat(savedRental.getRentalEndDate()).isEqualTo(rental.getRentalStartDate().plusMonths(1));
    }

    @Test
    @DisplayName("When update Rental, then PreUpdate callback should update updatedAt and rentalEndDate")
    void testPreUpdateCallbacks() throws InterruptedException {
        Rental rental = new Rental();
        rental.setTenantUserId(tenantId1);
        rental.setKosId(kosId1);
        rental.setOwnerUserId(ownerId1);
        rental.setSubmittedTenantName("Test Update");
        rental.setSubmittedTenantPhone("1234567890");
        rental.setRentalStartDate(LocalDate.now().plusDays(2));
        rental.setRentalDurationMonths(2);
        rental.setStatus(RentalStatus.PENDING_APPROVAL);

        Rental initialSave = entityManager.persistFlushFind(rental); // Persist, flush, and find to get managed entity
        LocalDateTime initialUpdatedAt = initialSave.getUpdatedAt();
        LocalDate initialEndDate = initialSave.getRentalEndDate();

        Thread.sleep(10);

        initialSave.setStatus(RentalStatus.APPROVED);
        initialSave.setRentalDurationMonths(3);
        Rental updatedRental = rentalRepository.saveAndFlush(initialSave);

        assertThat(updatedRental.getUpdatedAt()).isAfter(initialUpdatedAt);
        assertThat(updatedRental.getRentalEndDate()).isNotEqualTo(initialEndDate);
        assertThat(updatedRental.getRentalEndDate()).isEqualTo(initialSave.getRentalStartDate().plusMonths(3));
        assertThat(updatedRental.getStatus()).isEqualTo(RentalStatus.APPROVED);
    }


    @Test
    @DisplayName("findByTenantUserId should return rentals for a specific tenant")
    void findByTenantUserId_returnsMatchingRentals() {
        Rental rental1 = new Rental(null, tenantId1, kosId1, ownerId1, "T1 Kos1", "P1", LocalDate.now(), 1, null, RentalStatus.ACTIVE, null, null);
        Rental rental2 = new Rental(null, tenantId2, kosId1, ownerId1, "T2 Kos1", "P2", LocalDate.now(), 1, null, RentalStatus.ACTIVE, null, null);
        Rental rental3 = new Rental(null, tenantId1, kosId2, ownerId1, "T1 Kos2", "P3", LocalDate.now(), 1, null, RentalStatus.PENDING_APPROVAL, null, null);
        entityManager.persist(rental1);
        entityManager.persist(rental2);
        entityManager.persist(rental3);
        entityManager.flush();

        List<Rental> foundRentals = rentalRepository.findByTenantUserId(tenantId1);

        assertThat(foundRentals).hasSize(2);
        assertThat(foundRentals).extracting(Rental::getTenantUserId).containsOnly(tenantId1);
        assertThat(foundRentals).extracting(Rental::getSubmittedTenantName).containsExactlyInAnyOrder("T1 Kos1", "T1 Kos2");
    }

    @Test
    @DisplayName("findActiveRentalsFromDate should return correct rentals based on status and start date")
    void findActiveRentalsFromDate_returnsCorrectly() {
        LocalDate today = LocalDate.now();
        LocalDate yesterday = today.minusDays(1);
        LocalDate tomorrow = today.plusDays(1);

        Rental r1ActiveToday = new Rental(null, tenantId1, kosId1, ownerId1, "R1", "P", today, 1, null, RentalStatus.ACTIVE, null, null);
        Rental r2ActiveTomorrow = new Rental(null, tenantId1, kosId1, ownerId1, "R2", "P", tomorrow, 1, null, RentalStatus.ACTIVE, null, null);
        Rental r3PendingToday = new Rental(null, tenantId2, kosId2, ownerId1, "R3", "P", today, 1, null, RentalStatus.PENDING_APPROVAL, null, null);
        Rental r4ActiveYesterday = new Rental(null, tenantId2, kosId2, ownerId1, "R4", "P", yesterday, 1, null, RentalStatus.ACTIVE, null, null);

        entityManager.persist(r1ActiveToday);
        entityManager.persist(r2ActiveTomorrow);
        entityManager.persist(r3PendingToday);
        entityManager.persist(r4ActiveYesterday);
        entityManager.flush();

        List<Rental> activeFromToday = rentalRepository.findActiveRentalsFromDate(RentalStatus.ACTIVE, today);

        assertThat(activeFromToday).hasSize(2);
        assertThat(activeFromToday).extracting(Rental::getSubmittedTenantName).containsExactlyInAnyOrder("R1", "R2");

        List<Rental> activeFromTomorrow = rentalRepository.findActiveRentalsFromDate(RentalStatus.ACTIVE, tomorrow);
        assertThat(activeFromTomorrow).hasSize(1);
        assertThat(activeFromTomorrow).extracting(Rental::getSubmittedTenantName).containsExactly("R2");
    }

    @Test
    @DisplayName("findByRentalEndDateBeforeAndStatusIsNot should find completed or old pending rentals")
    void findByRentalEndDateBeforeAndStatusIsNot_findsOldRentals() {
        LocalDate today = LocalDate.now();
        Rental r1EndedYesterday = new Rental(null, tenantId1, kosId1, ownerId1, "R1", "", today.minusMonths(1).minusDays(1), 1, null, RentalStatus.COMPLETED, null, null);
        // @PrePersist in Rental will calculate rentalEndDate for r1EndedYesterday as today.minusDays(1)

        Rental r2PendingOld = new Rental(null, tenantId1, kosId1, ownerId1, "R2", "", today.minusMonths(2), 1, null, RentalStatus.PENDING_APPROVAL, null, null);
        // @PrePersist calculates rentalEndDate for r2PendingOld as today.minusMonths(1)

        Rental r3ActiveFutureEnd = new Rental(null, tenantId2, kosId2, ownerId1, "R3", "", today, 1, null, RentalStatus.ACTIVE, null, null);
        // @PrePersist calculates rentalEndDate for r3ActiveFutureEnd as today.plusMonths(1)

        Rental r4CancelledOld = new Rental(null, tenantId2, kosId2, ownerId1, "R4", "", today.minusMonths(3), 1, null, RentalStatus.CANCELLED, null, null);
        // @PrePersist calculates rentalEndDate for r4CancelledOld as today.minusMonths(2)


        entityManager.persist(r1EndedYesterday);
        entityManager.persist(r2PendingOld);
        entityManager.persist(r3ActiveFutureEnd);
        entityManager.persist(r4CancelledOld);
        entityManager.flush();

        List<Rental> oldNonCompletedRentals = rentalRepository.findByRentalEndDateBeforeAndStatusIsNot(today, RentalStatus.COMPLETED);

        assertThat(oldNonCompletedRentals).hasSize(2);
        assertThat(oldNonCompletedRentals).extracting(Rental::getSubmittedTenantName)
                .containsExactlyInAnyOrder("R2", "R4");

        List<Rental> oldNonCancelledRentals = rentalRepository.findByRentalEndDateBeforeAndStatusIsNot(today, RentalStatus.CANCELLED);
        assertThat(oldNonCancelledRentals).hasSize(2);
        assertThat(oldNonCancelledRentals).extracting(Rental::getSubmittedTenantName)
                .containsExactlyInAnyOrder("R1", "R2");

    }
}
